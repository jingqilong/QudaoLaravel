# Array Model
  
## 简介

* 你可以这样使用：

```
    ArrayModel::select('a.id','a.name','a.age','b.subject','b.score')
    ->from($src_array, 'a')
    ->join($score_array,'b')
    ->on(['a.id','=','b.student_id')
    ->where(['b.score','>=',60])
    ->get()
    ->toArray();
```

* 你可能要问，$score_array从哪里来？
    你可以这么做：
    
```
    $model = ArrayModel::select('a.id','a.name','a.age','b.exam_date',b.subject','b.score')
                 ->from($src_array, 'a');
    $student_id_array = $model->pluck('a.id');
    //通过以上语句拿到ID，你就可以到数据库里用 select in ()查询了
    //接下来：
    $model->join($score_array,'b')
          ->on(['a.id','=','b.student_id');
    $result = $model->get()->toArray();
    
    //接下来你还可以
    $model->where(['b.score','>',0])
    $result_a = $model->get()->toArray();
    
    //甚致还可以，
    $model->where(['b.score','>',0])
    ->groupBy('a.id','b.subject_id')
    ->orderBy(['a.id','adc'],['b.score','desc'])
    $result_b = $model->get()->toArray();
    
    //甚致还可以,通过闭包回调进行自定义处理
    $result_b = $model->get(
        function($src_item,$join_item){
            $result = $src_item;
            $result['exam_date']= date("Y年m月d日" $join_item['exam_date']);
            $result['subject'] = $join_item['subject'];
            $result['score'] = $join_item['score'];
            return $result;
    })->toArray(); 
    
    
```
  
## 为什么需要它？

### 缘起

* 曾经遇到过一个十年的码农，在foreach内查询数据库。

* 曾遇到过新手程序员，通过嵌套foreach实现两数组的联表。

* 更基础的，多维数组，如何排序与分页？

* 因为以上各类初级的写法，程序效率非常低下。

* 上网寻找同类组件时，只找到了ArrayJoin，可这个组件，几乎与码农写的无差别。同样是嵌套foreach。没有办法，只能自己撸一个了。

### 可能的需求

* 新手程序员经常会在foreach中嵌套数据库查询。使用它，虽然只查了两个表，但数据库只访问了两次。本人就曾遇到10年的老程序员，在foreach中使用循环查数据库。有了它，你就要可以把这个行为禁掉。不会让你Code Review时发疯。

* 大厂都规定，数据库联表查询，不允许超过三个表。有些表，比如，状态表，类型定义，分类定表等表则是需要缓存，并在查询结果出来后进行后续联表操作的。这不只是减轻数据库负担，同时也是让程序更加简洁。

* 有时会遇到外部的导入数据，或者像处理文件目录那样，没有直接分页的。并且，也是要处理的。

* 本组件使用了数组索引的方法提升效率。初级程序员常会把join的表也查出来。再用foreach嵌套，到join的表中找到对应的记录。本组件是通过将join的表用关联字段作为数组的key进行索引。从而使本来是乘法运算次数的，现在变成了加法的次数。比如，原来都是10条记录，那么，foreach嵌套是查询次数最高会是10*10=100次。而在则是 10+10=20次，从而提升了效率。

* 还有一些特殊的报表。比如上例，要查出，60分以上的人，以及总人数，60分以下的，以及总人数，这些操作均可以在程序中一并完成，而不再需要数据库。

### 功能说明

#### 基本功能
   
通过PHP实现两个数组的联表查询。  

#### 原理与效率

##### 原理

1、首先通过Pluck在主表中查出要关联的ID。
    
2、到数据库中用select in()一次查出要关联的记录。
    
3、根据关联关系，以关联表的字段用数组的key对关联表数据进行MAP（索引）。
    
4、合并两个数组。
  
##### 效率：

因为，基于索引，所以，不再需要搜索关联表。直接用key直检索。
    
由此，原来是10*10次计算，现在则是10+10次计算。效率大大提高。
    
同时，代码也简洁可读。

如果想让你的小伙伴快速开发，且让你不会在Code Review时崩溃，那就赶快用它吧。
 
#### 附加功能
 
二维数组的排序，筛选。 

## 优势

* 使用此组件，你可以规范码农的代码。

* 使用此组件，同时也可以提升PHP程序的效率，避免码农低效的代码。也尽最大可能降低了数组操作的次数

* 使用了逻辑树化简算法对join数组索引进行优化。从而大大提升了运算效率。

## 环境需求：
    
    Php版本 >= `7.2`
    
    本组件未使用任何第三方组件。
    
    推荐集成在Laravel 5.8 及以上的版本中。
    
    当然，像Yii2, Symfony3, WorkerMan3.0，Swoft，FastD等理应都可以集成，如有问题，请在issuse中反馈。
    
    【注：本组件无法及时考虑ThinkPhp的问题！敬请谅解！】

## 安装
    
```
    $ composer require bardoqi\arraymodel:dev
```    
    
## API向导：

### 说明：
    
本组件API均是尽最大可能与Laravel框架的Model保持一致。但由于本组件是操作数组的，不是操作数据库的，所以，像WhereRaw这样的函数就无法实现。（当然也是不无法实现，真的要实现，则要使用AST，即：Abstract Syntax Tree,但若使用了AST，则效率必须会降低。）

### API清单：




## 相关不足

* 关联条件：虽然有逻辑树优化算法，但是，只做了交换律与结合律，逻辑算法共有10个运算律（不清楚的，可以上网查一下），但考虑到，如果这些算法都实现，那么，得不偿失。因为，本来是为了提升效率的。但过于复杂的算法会使效率降低。所以，如果你SQL中的on关联条件很复杂，那建议你还是在数据库中完成。（当然，如果可能，还是优化一下你的数据表。）所以，建议在使用时，尽量不要让逻辑树去跑化简程序，虽说对效率影响不大。具体怎么做呢？其实，只要了解交换律与结合律，将AND与OR合并到一起即可。

* where条件。因为无法判筛选后关联和先关联后筛选哪一个效率更高。（实际上取决于记录的数量，记录数越多，先筛选会越好），现在使用的是先关联后筛选的算法。因为考虑到如果页面显示，一般10到20条每页。

## 版权与授权

### 版权
  
    CopyRight: Bardo QI 
    Email: 67158925@qq.com
  
### 授权
  
    MIT license
    
## 技术支持
   
    QQ: 67158925
    
## 损赠
    
如果你觉得本组件好，希望能持续支持与改进，请您帮我买杯咖啡！
    
    
